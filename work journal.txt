1. Petalinux stuck
  ... 0110
  (1) replace u-boot.elf && fsbl.elf in the platform - petalinux
  (2) booting processes


2. SDSoC project - 3D image rendering
  (1) BRAM size limitation - 16384 - how to figure this out?
      - 4 smaller arrays
      - some settings/pragmas
  (2) Build FIFO in SDSoC

ug902
#pragma AP interface ap_fifo port=data_i
#pragma AP interface ap_fifo port=data_o


*#pragma SDS data_mover(ArrayName:DataMover)
(This pragma is not recommended for normal useï¼‰

#pragma SDS data mem_attribute(ArrayName:cache|contiguity) 
cache : CACHEABLE or NON_CACHEABLE.
default : CACHEABLE.
CACHEABLE means that the compiler must maintain cache coherency between the CPU and accelerator.
NON-CACHEABLE means that the compiler does not need to ensure the cache coherency of the specified memory.
Software code does not read or write the video data so the cache coherency between processor and accelerator is not required. 
Continuity : PHYSICAL_CONTIGUOUS or NON_PHYSICAL_CONTIGUOUS
default : NON_PHYSICAL_CONTIGUOUS
PHYSICAL_CONTIGUOUS means that memory is allocated using sds_alloc.
NON_PHYSICAL_CONTIGUOUS means that memory is allocated using malloc. 

#pragma SDS data copy|zero_copy(ArrayName[offset:length])
The data copy implies that data is explicitly copied from the processor memory to the hardware function. 
The data zero_copy means that the hardware function accesses the data directly from shared memory. 
Within a synthesizeable hardware function, it is usually inefficient to read/write single words from the shared memory (specified using the zero-copy pragma). A more efficient approach is to employ memcpy to read/write data from memory in bursts and store it in a local memory

#pragma SDS data access_pattern(arguement : SEQUENTIAL | RANDOM)
we use sequential to allocate FIFO interface and use RANDOM to allocate BRAM interface.

*#pragma SDS buffer_depth(ArrayName:BufferDepth)
*#pragma SDS async(ID)
*#pragma SDS wait(ID)

#pragma HLS INLINE
#pragma HLS PIPELINE II=1
#pragma HLS unroll factor=2
#pragma HLS AP 
#pragma HLS dataflow
#pragma HLS array_shape

local memory: for a single function
shared memory: for several functions 
global memory: for all

arguements data type of hardware function: 8,16,32,64bit 

how to use contiguous memory:
The sdscc/sds++ compilers analyze your program and selects data movers to match the requirements for each hardware function call between software and hardware, based on payload size, hardware interface on the accelerator, and properties of the function arguments. When the compiler can guarantee an array argument is located in physically contiguous memory, it can use the most efficient data movers. Allocating or memory-mapping arrays with the following sds_lib library functions can inform the compiler that memory is physically contiguous. 
sds_alloc(size_t size); // guarantees physically contiguous memory
sds_mmap(void *paddr, size_t size, void *vaddr); // paddr must point to
contiguous memory
sds_register_dmabuf(void *vaddr, int fd); // assumes physically contiguous
memory
#pragma SDS data mem_attribute (A:PHYSICAL_CONTIGUOUS) // default is
NON_PHYSICAL_CONTIGUOUS

 Because the intermediate array variable tmp1 is used only to pass data between the two hardware functions, the sdscc system compiler chains the two functions together in hardware with a direct connection between them.
 In the example shown in the diagram, the mmult and madd functions run concurrently whenever their inputs become available. The ensemble of function calls is orchestrated in the compiled program by control code automatically generated by sdscc according to the program, data mover, and accelerator structure.




