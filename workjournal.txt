# some open issues in our work, this file will be deleted later...
1. Petalinux stuck
  ... 0110
  (1) replace u-boot.elf && fsbl.elf in the platform - petalinux
  (2) booting processes


2. SDSoC project - 3D image rendering
  (1) BRAM size limitation - 16384 - how to figure this out?
      - 4 smaller arrays
      - some settings/pragmas
  (2) Build FIFO in SDSoC


the meaning of zero_copy:
we dont copy any data to hardware function.The HW read and write data from external DDR memory as need. So zero_copy means the allocation of shared memory.
for pointer: we can use 
#pragma SDS data access_pattern(A:SEQUENTIAL)  
and #pragma SDS data copy(p[0:<array_size>]) // for example, int *p
we can vary the array size in the second line, use some scalar arguments.








pass by reference 

*#pragma SDS data_mover(ArrayName:DataMover)
(This pragma is not recommended for normal use）

#pragma SDS data mem_attribute(ArrayName:cache|contiguity) 
cache : CACHEABLE or NON_CACHEABLE.
default : CACHEABLE.
CACHEABLE means that the compiler must maintain cache coherency between the CPU and accelerator.
NON-CACHEABLE means that the compiler does not need to ensure the cache coherency of the specified memory.
Software code does not read or write the video data so the cache coherency between processor and accelerator is not required. 
Continuity : PHYSICAL_CONTIGUOUS or NON_PHYSICAL_CONTIGUOUS
default : NON_PHYSICAL_CONTIGUOUS
PHYSICAL_CONTIGUOUS means that memory is allocated using sds_alloc.
NON_PHYSICAL_CONTIGUOUS means that memory is allocated using malloc. 

#pragma SDS data copy|zero_copy(ArrayName[offset:length])
The data copy implies that data is explicitly copied from the processor memory to the hardware function. 
The data zero_copy means that the hardware function accesses the data directly from shared memory. 
Within a synthesizeable hardware function, it is usually inefficient to read/write single words from the shared memory (specified using the zero-copy pragma). A more efficient approach is to employ memcpy to read/write data from memory in bursts and store it in a local memory

#pragma SDS data access_pattern(arguement : SEQUENTIAL | RANDOM)
we use sequential to allocate FIFO interface and use RANDOM to allocate BRAM interface.

*#pragma SDS buffer_depth(ArrayName:BufferDepth)

#pragma HLS INLINE
#pragma HLS PIPELINE II=1
#pragma HLS unroll factor=2
#pragma HLS AP 
#pragma HLS dataflow
#pragma HLS array_shape

local memory: for a single function
shared memory: for several functions 
global memory: for all

arguements data type of hardware function: 8,16,32,64bit 

how to use contiguous memory:
The sdscc/sds++ compilers analyze your program and selects data movers to match the requirements for each hardware function call between software and hardware, based on payload size, hardware interface on the accelerator, and properties of the function arguments. When the compiler can guarantee an array argument is located in physically contiguous memory, it can use the most efficient data movers. Allocating or memory-mapping arrays with the following sds_lib library functions can inform the compiler that memory is physically contiguous. 
sds_alloc(size_t size); // guarantees physically contiguous memory
sds_mmap(void *paddr, size_t size, void *vaddr); // paddr must point to
contiguous memory
sds_register_dmabuf(void *vaddr, int fd); // assumes physically contiguous
memory
#pragma SDS data mem_attribute (A:PHYSICAL_CONTIGUOUS) // default is
NON_PHYSICAL_CONTIGUOUS


Because the intermediate array variable tmp1 is used only to pass data between the two hardware functions, the sdscc system compiler chains the two functions together in hardware with a direct connection between them.
In the example shown in the diagram, the mmult and madd functions run concurrently whenever their inputs become available. The ensemble of function calls is orchestrated in the compiled program by control code automatically generated by sdscc according to the program, data mover, and accelerator structure.
#pragma SDS async(<id>)
#pragma SDS async(<id>)

zero_copy  shared memory both read/write
memcpy     store large size of data into local memory 
access_pattern(SEQUENTIAL）  streaming access pattern
mem_attribute physically contiguous memory

SDSOC includes: a. macro-architechture(vivado HLS)
                b. data mover level(system level, data flow, #pragma SDS)
                
Pointer arguments for a hardware function require special consideration.

 You must use sds_alloc to allocate an array for the following two cases: 1. You are using zero-copy pragma for the array. 2. You are using pragmas to explicitly direct the system compiler to use Simple-DMA or 2D-DMA. Note that in order to use sds_alloc() from sds_lib.h, it is necessary to include stdlib.h before including sds_lib.h. stdlib.h is included to provide the size_t type.

Because a function with incompatible HLS interface types can result in cryptic sdscc error messages, it is strongly recommended (though not absolutely mandatory) that you omit HLS interface pragmas

A top-level hardware function should not contain any HLS interface pragmas. In this case, the SDSoC environment generates appropriate HLS interface directives. There are two SDSoC environment pragmas you can specify for a top-level hardware function to guide the SDSoC environment to generate the desired HLS interface directives. #pragma SDS data zero_copy() can be used to generate a shared memory interface implemented as an AXI master interface in hardware. #pragma SDS data access_pattern(argument:SEQUENTIAL) can be used to generate a streaming interface implemented as a FIFO interface in hardware.

3. Avoid using arrays of struct. An array of struct has different memory layout between ARM GCC and Vivado HLS. In the future, the SDSoC environment will support array of struct with a compatible memory layout between ARM GCC and Vivado HLS. 4. Avoid usingap_int<>, ap_fixed<>, hls::stream, except with data width of 8, 16, 32 or 64 bits. Navigate to <SDSoC Installation Path>/samples/hls_if/hls_stream for a sample design on how to use hls::stream in the SDSoC environment.

 Data transport using a DMA data mover requires AXI4-Stream TLAST, TKEEP side band signals, which must be explicitly coded within HLS code.

NOTE: To use the library, #include "sds_lib.h" in source files. You must include stdlib.h before including sds_lib.h to provide the size_t type declaration. 
void *sds_alloc(size_t size) Allocate a physically contiguous array of size bytes. 

RAM – using #pragma SDS data access_pattern(A:RANDOM) immediately preceding the accelerator function declaration. The SDSoC environment automatically maps onto a packetized AXI4-Stream channel compatible with the DMA protocol, with optional multi-buffering at the accelerator. A hardware function can have no more than eight input bram or ap_fifo arguments and no more than eight output bram or ap_fifo arguments. The example <sdsoc_install_dir>/samples/hls_if/mmult_hls_bram demonstrates how to use BRAM interfaces in the SDSoC environment. • FIFO – using #pragma SDS data access_pattern(A:SEQUENTIAL) immediately preceding the accelerator function declaration. The SDSoC environment automatically maps onto a packetized AXI4-Stream channel compatible with the DMA protocol. A hardware function can have no more than eight input bram or ap_fifo arguments and no more than eight output bram or ap_fifo arguments. The example <sdsoc_install_dir>/samples/hls_if/mmult_hls_ap_fifo demonstrates how to use HLS ap_fifo interfaces in the SDSoC environment. 
